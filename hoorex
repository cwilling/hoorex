#!/usr/bin/env python
#
# ex:set ai shiftwidth=4 inputtab=spaces smarttab noautotab:

from __future__ import print_function

import sys, os
import fnmatch
import subprocess
import pickle
from xdg.BaseDirectory import *
import argparse
import logging
import ConfigParser
import re


# How we were called
(apppath, appname) = os.path.split(sys.argv[0])

with open('VERSION.txt', 'rb') as f:
    VERSION = f.read().strip()

logging.basicConfig(format='%(levelname)s: %(message)s')
hlog = logging.getLogger(appname)

# How far into requirements tree to go
DEPTH_LIMIT  = 10


def main():
    # User configuration
    default_config = load_user_config()

    # Command line arguments
    parser = argparse.ArgumentParser(description="This program shows which \
                    other packages require a given SBo package")
    parser.add_argument("-f", "--force", action="store_true", dest="force",
                default=default_config.getboolean('HooRex', 'force'),
                help="force (re)processing of repo data")
    parser.add_argument("-m", "--multilevel", action="store_true", dest="multilevel",
                default=default_config.getboolean('HooRex', 'multilevel'),
                help="after finding immediate requirers, show who requires those")
    parser.add_argument("-d", "--debug", action="store_true", dest="debug_mode",
                default=default_config.getboolean('HooRex', 'debug'),
                help="show additional additional debugging information, \
                    not just calculated package names")
    parser.add_argument("-l", "--long", action="store_true", dest="output_long",
                default=default_config.getboolean('HooRex', 'output_long'),
                help="show containing directory (category) for each package")
    parser.add_argument('-s', '--slackbuilds', dest='sbo_path', action='store',
                help="set the full filesystem path to the local slackbuilds \
                    repository e.g. -s /home/jerry/slackbuilds")
    parser.add_argument("-v", "--version", dest="app_version", action="store_true",
                help="display version number and exit")
    parser.add_argument("target", metavar='PKG', type=str, nargs='*',
                help="package(s) to process")

    args = parser.parse_args()

    # Allow packages to be taken from stdin as well as a command argument
    if not sys.stdin.isatty():
        pipe_targets = sys.stdin.read().split()
    else:
        pipe_targets = []

    if args.app_version:
        print(VERSION)
        sys.exit(0)

    if args.debug_mode:
        hlog.setLevel(logging.DEBUG)
        hlog.debug("VERBOSE mode set at command line")
    else:
        hlog.setLevel(logging.INFO)

    if args.sbo_path is not None:
        sbo_path = args.sbo_path.split()[-1]
        # If no SBO_PATH exists, set it in config defaults
        if  not default_config.has_option('HooRex', 'sbo_path'):
            user_config_set(default_config, 'sbo_path', sbo_path)
    elif default_config.has_option('HooRex', 'sbo_path'):
        sbo_path = default_config.get('HooRex', 'sbo_path')
        hlog.debug("Set sbo_path to %s from config file" % sbo_path)
    else:
        sbo_path = find_sbo_path()
    hlog.debug("sbo_path: %s" % sbo_path)

    # Repo Data
    data_dir = os.path.join(xdg_data_home, appname)
    if not os.path.isdir(data_dir):
        os.mkdir(data_dir)
    SAVED_DATA=os.path.join(data_dir, 'repoData.pkl')

    # Our personal database of package relationships
    PkgData = dict()

    if args.force == False and os.path.exists(SAVED_DATA):
        # First try to load preexisting data
        hlog.debug("Loading existing repo data")
        pkl_file = open(SAVED_DATA, 'rb')
        PkgData = pickle.load(pkl_file)
        pkl_file.close()
        hlog.debug("PkgData loaded from file OK")
    else:
        if args.force == True:
            hlog.debug("(re)build of repo data forced by -f option - please wait ...")
        elif not os.path.exists(SAVED_DATA):
            hlog.debug("Couldn't open data file, generating new data - please wait ...")
        build_dicts(sbo_path, PkgData)
        output = open(SAVED_DATA, 'wb')
        # Pickle the list using the highest protocol available.
        pickle.dump(PkgData, output, -1)
        output.close()
    PkgRequires = PkgData['PkgRequires']
    PkgNeededBy = PkgData['PkgNeededBy']
    PkgCategory = PkgData['PkgCategory']

    multilevel_depth = 0
    targets = set(pipe_targets + args.target)
    hlog.debug("Processing initial targets of: %s" % targets)
    multi_list = []
    multi_list.append(targets)
    while True:
        if len(targets) < 1:
            break
        hlog.debug("At LEVEL %d, required by: %s" % (multilevel_depth, targets))
        pkglist = []
        for package in targets:
            if PkgRequires.has_key(package):
                if PkgNeededBy.has_key(package):
                    hlog.debug("\t%s is needed by: %s" % (package, PkgNeededBy[package]))
                    pkglist.extend(PkgNeededBy[package])
                else:
                    hlog.debug("\t%s isn't needed by any other package" % package)
            else:
                hlog.debug("\tSkipping package \"%s\" (unknown package)" % package)

        if len(pkglist) > 0:
            multi_list.append(pkglist)
        if not args.multilevel or len(targets) < 1:
            break
        targets = list(set(pkglist))
        multilevel_depth += 1
        if multilevel_depth > DEPTH_LIMIT:
            break

    # Everything (including initial pkgs enquired about)
    hlog.debug(multi_list)

    # OUTPUT
    for requirers in multi_list:
        for req in requirers:
            if args.output_long:
                print(os.path.join(PkgCategory[req], req), end=' ')
            else:
                print(req, end=' ')
    print()


def build_dicts(sbo_path, PkgData, deptarget='REQUIRES'):

    here = os.getcwd()
    os.chdir(sbo_path)
    hlog.debug("Using %s to index dependencies" % deptarget)
    if deptarget == 'PREREQS':
        reg = re.compile('(?P<name>PREREQS)="(?P<value>.*?)"', re.DOTALL)
    elif deptarget == 'REQUIRES':
        reg = re.compile('(?P<name>REQUIRES)="(?P<value>.*?)"', re.DOTALL)
    else:
        hlog.critical("Unknown dependency target name (%s)" % deptarget)
        return

    BasicRequires = dict()
    PkgRequires = dict()
    PkgCategory = dict()
    PkgNeededBy = dict()

    # Step 1 - Create record of all SBo apps and their direct deps.
    #          Save as BasicRequires (which is later extended into PkgRequires)
    for dirpath, dirnames, filenames in os.walk('.'):
        for filenm in filenames:
            if fnmatch.fnmatch(filenm, '*.info'):
                #print(os.path.split(dirpath)[0].strip('.').strip('/'))
                #print(os.path.join(dirpath, filenm))
                category = os.path.split(dirpath)[0].strip('.').strip('/')
                pkgname = os.path.split(dirpath)[-1]
                if pkgname + '.info' == filenm:
                    with open(os.path.join(dirpath, filenm), 'rb') as f:
                        txt = f.read()
                    m = reg.search(txt)
                    if m:
                        value = ''
                        if m.group('value'):
                            value = m.group('value')
                        hlog.debug("Adding %s ----- (%s)" % (pkgname, value))
                        PkgCategory[pkgname] = category
                        BasicRequires[pkgname] = value.split()

    #print
    hlog.debug("Step 1 done - %d entries" % len(BasicRequires))

    # Step 2 - Find extended requirements by traversing dependency tree.
    #          Save result as PkgRequires
    for (k,v) in BasicRequires.iteritems():
        multilevel_depth = 0
        targets = v
        multi_list = []
        multi_list.extend(targets)
        while True:
            if len(targets) < 1:
                break

            pkglist = []
            for package in targets:
                if BasicRequires.has_key(package):
                    pkglist.extend(BasicRequires[package])

            if len(pkglist) > 0:
                multi_list.extend(pkglist)
            targets = list(set(pkglist))
            multilevel_depth += 1
            if multilevel_depth > DEPTH_LIMIT:
                break

        PkgRequires[k] = multi_list


    # Step 3 - Generate record of which other pkgs require each SBo pkg
    #          Save as PkgNeededBy
    for k, v in PkgRequires.iteritems():
        #print("%s ----- %s" % (k, v))
        if len(v) > 0:
            #print("%s ----- %s" % (k, v))
            for required in v:
                if not PkgNeededBy.has_key(required):
                    PkgNeededBy[required] = []
                PkgNeededBy[required].extend(k.split())
    hlog.debug("Step 2 done - %d entries" % len(PkgNeededBy))

    PkgData['PkgRequires'] = PkgRequires
    PkgData['PkgNeededBy'] = PkgNeededBy
    PkgData['PkgCategory'] = PkgCategory

    os.chdir(here)


def load_user_config():
    config_dir = os.path.join(xdg_config_home, appname)
    config_file = os.path.join(config_dir, 'defaults.cfg')
    user_config = ConfigParser.ConfigParser()

    # No user configuration file exists so generate a default one
    if not os.path.isdir(config_dir) or not os.path.exists(config_file):
        try:
            os.mkdir(config_dir)
        except:
            pass
        user_config.add_section('HooRex')
        user_config.set('HooRex', 'force', 'False')
        user_config.set('HooRex', 'output_long', 'False')
        user_config.set('HooRex', 'multilevel', 'False')
        user_config.set('HooRex', 'debug', 'False')

        with open(config_file, 'wb') as configfile:
            user_config.write(configfile)
        configfile.close()
    else:
        user_config.read(config_file)
    return user_config

def find_sbo_path():
    hlog.critical("SBO_PATH is not set. Please set it using the -s (--slackbuilds) option e.g.\n hoorex -s /home/thomas/slackbuilds")
    sys.exit(1)

def user_config_set(user_config, key, value):
    config_dir = os.path.join(xdg_config_home, appname)
    config_file = os.path.join(config_dir, 'defaults.cfg')

    # We assume we have been given a valid key & value
    user_config.set('HooRex', key, value)
    with open(config_file, 'wb') as configfile:
        user_config.write(configfile)
    configfile.close()


if __name__ == '__main__':
    main()
